#ifndef PATH_H
#define PATH_H

#include <cstring>
#include <vector>

#include <ros/ros.h>
#include <tf/transform_datatypes.h>
#include <nav_msgs/Path.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/PoseArray.h>
#include <visualization_msgs/MarkerArray.h>
#include "parameter_manager.h"
// #include "node3d.h"
// namespace HybridAStar {
// /*!
//    \brief A class for tracing and visualizing the path generated by the Planner
// */
// class Path {
//  public:
/// The default constructor initializing the path object and setting publishers for the same.
//     Path(const ParameterPath &params, bool smoothed = false)
//     {
//        params_ = params;
//        std::string pathTopic = "/path";
//        std::string pathNodesTopic = "/pathNodes";
//        std::string pathVehicleTopic = "/pathVehicle";

//        if (smoothed)
//        {
//           pathTopic = "/sPath";
//           pathNodesTopic = "/sPathNodes";
//           pathVehicleTopic = "/sPathVehicle";
//           this->smoothed_ = smoothed;
//        }

//        // _________________
//        // TOPICS TO PUBLISH
//        pub_path_ = nh_.advertise<nav_msgs::Path>(pathTopic, 1);
//        pub_path_nodes_ = nh_.advertise<visualization_msgs::MarkerArray>(pathNodesTopic, 1);
//        pub_path_vehicles_ = nh_.advertise<visualization_msgs::MarkerArray>(pathVehicleTopic, 1);

//        // CONFIGURE THE CONTAINER
//        path_.header.frame_id = "path";
//     }

//   //  /*!
//   //     \brief Given a node pointer the path to the root node will be traced recursively
//   //     \param node a 3D node, usually the goal node
//   //     \param i a parameter for counting the number of nodes
//   //  */
//   //  void TracePath(const Node3D* node, int i = 0);
//   /*!
//      \brief Given a node pointer the path to the root node will be traced recursively
//      \param node a 3D node, usually the goal node
//      \param i a parameter for counting the number of nodes
//   */
//     void UpdatePath(const std::vector<Node3D> &nodePath);
//     /*!
//      \brief Adds a segment to the path
//      \param node a 3D node
//   */
//     void AddSegment(const Node3D &node);
//     /*!
//      \brief Adds a node to the path
//      \param node a 3D node
//      \param i a parameter for counting the number of nodes
//   */
//     void AddNode(const Node3D &node, int i);
//     /*!
//      \brief Adds a vehicle shape to the path
//      \param node a 3D node
//      \param i a parameter for counting the number of nodes
//   */
//     void AddVehicle(const Node3D &node, int i);

//     // ______________
//     // PUBLISH METHODS

//     /// Clears the path
//     void Clear();
//     /// Publishes the path
//     void PublishPath() { pub_path_.publish(path_); }
//     /// Publishes the nodes of the path
//     void PublishPathNodes() { pub_path_nodes_.publish(path_nodes_); }
//     /// Publishes the vehicle along the path
//     void PublishPathVehicles() { pub_path_vehicles_.publish(path_vehicles_); }

//  private:
//   /// A handle to the ROS node
//     ros::NodeHandle nh_;
//     /// Publisher for the path as a spline
//     ros::Publisher pub_path_;
//     /// Publisher for the nodes on the path
//     ros::Publisher pub_path_nodes_;
//     /// Publisher for the vehicle along the path
//     ros::Publisher pub_path_vehicles_;
//     /// Path data structure for visualization
//     nav_msgs::Path path_;
//     /// Nodes data structure for visualization
//     visualization_msgs::MarkerArray path_nodes_;
//     /// Vehicle data structure for visualization
//     visualization_msgs::MarkerArray path_vehicles_;
//     /// Value that indicates that the path is smoothed/post processed
//     bool smoothed_ = false;
//     ParameterPath params_;
// };
// }
// #endif // PATH_H
