/**
 * @file genetic_algorithm.h
 * @author Jialiang Han
 * @brief main class for GA
 * @version 0.1
 * @date 2021-12-25
 * 
 * @copyright Copyright (c) 2021
 * 
 */
#pragma once
#include <vector>
#include <eigen3/Eigen/Dense>
#include "piecewise_cubic_bezier.h"
#include "parameter_manager.h"
#include "collision_detection.h"
#include <cstdlib>
#include <math.h>
#include <unordered_map>
namespace GeneticAlgorithm
{
   /**
    * @brief control point of bezier
    * 
    */
   typedef Eigen::Vector3d Genotype;
   /**
    * @brief list of control point, not include start and goal, is to generate piecewise cubic bezier path
    * 
    */
   typedef std::vector<Genotype> Chromosome;
   typedef std::vector<Chromosome> Population;

   typedef std::pair<Chromosome, Chromosome> BreedingPair;
   /**
    * @brief both key and value are chromosome, generated by select process,the size should be the generation size/
    * 
    */
   typedef std::vector<BreedingPair> MatingPool;
   /*!
   * \brief A class that encompasses the functions central to the search.
   */
   class GeneticAlgorithm
   {

   public:
      GeneticAlgorithm(){};
      GeneticAlgorithm(const ParameterGeneticAlgorithm &param)
      {
         params_ = param;
      };
      void Initialize(const Eigen::Vector3d &start, const Eigen::Vector3d &goal, const nav_msgs::OccupancyGrid::ConstPtr &map)
      {
         start_ = start;
         goal_ = goal;
         collision_detection_ptr_.reset(new CollisionDetection(map));
         grid_ = map;
         current_best_.second = 0;
         best_of_best_.second = 0;
         MainLoop();
      };

      std::vector<Eigen::Vector3d> GetPath() { return path_; };
      /**
       * @brief Get All anchor and control Points for the path
       * 
       * @return Chromosome 
       */
      Chromosome GetPoints();

   private:
      /**
       * @brief check if there is a cubic bezier path connected from start to goal, if yes return this path.
       * 
       * @return int : 1, found path, 0 in collision
       */
      int PreCheck();
      void SelectAndCrossover();
      /**
       * @brief this is the main loop for GA
       * 
       */
      void MainLoop();
      Genotype GenerateRandomGeno();
      Chromosome GenerateRandomChromosome(const uint &number_of_genes);
      Population GenerateRandomPopulation(const uint &population_size);
      PiecewiseCubicBezier GeneratePiecewiseCubicBezier(const Chromosome &chromosome);
      void GenerateInitialPopulation();
      /**
       * @brief Calculate fitness value of a path,
             * equation is f(x)=1/(L(path)+p*q)
             * L(path): path length
             * p: penalty
             * q: number of times path encouters obstacle
       * 
       * @param chromosome 
       * @return float 
       */
      float CalculateFitness(const Chromosome &chromosome);
      void GenerateFitnessMap();
      void GenerateProbabilityMap();

      /**
       * @brief select based on probability density function
       * 
       * @return MatingPool 
       */
      BreedingPair Select();

      MatingPool GenerateMatingPool();
      /**
       * @brief find the location j chromosome_1 first encouter obstacle, transfer  0~ j-1 genes to chromosome_2
       * 
       * @param chromosome_1 
       * @param chromosome_2 
       * @return Chromosome 
       */
      Chromosome Crossover(const Chromosome &chromosome_1, const Chromosome &chromosome_2);
      /**
       * @brief randomly reproduce a free anchor point set
       * 
       * @param chromosome_1 
       */
      void GlobalMutation(Chromosome &chromosome);
      /**
       * @brief for each free anchor point, modify thse points within a predefined range(local search range radius)
       * 
       * @param chromosome_1 
       */
      void LocalMutation(Chromosome &chromosome);
      Population Mutation();

      void CalculatePath(const Chromosome &chromosome);

   private:
      Eigen::Vector3d start_;
      Eigen::Vector3d goal_;
      ParameterGeneticAlgorithm params_;

      std::pair<Chromosome, float> best_of_best_;

      std::pair<Chromosome, float> current_best_;
      /**
       * @brief number of generations which f(best of best)>= f(x best)
       * 
       */
      int h_;
      /**
       * @brief number of free anchor points(genes) in chromosome, this number must greater than 1. 
       * 
       */
      int number_of_gene_in_chromosome_ = 1;
      /**
       * @brief current generation, a vector of chromosome 
       * 
       */
      Population generation_;
      /**
       * @brief key is  fitness value ,value is chromosome
       * 
       */
      std::unordered_map<float, Chromosome> fitness_map_;
      /**
       * @brief key is chromosome, value is accumulated fitness value/(total fitness ), this map is for selection purposes
       * 
       */
      std::map<float, Chromosome> probability_map_;

      std::shared_ptr<CollisionDetection> collision_detection_ptr_;

      nav_msgs::OccupancyGrid::ConstPtr grid_;

      std::vector<Eigen::Vector3d> path_;

      float fitness_avg_ = 0;
   };
}
