/**
 * @file path_publisher.h
 * @author Jialiang Han (hanjiali@umich.edu)
 * @brief main function is to publish path found by algorithm
 * @version 0.1
 * @date 2021-12-27
 * 
 * @copyright Copyright (c) 2021
 * 
 */

#pragma once

#include <cstring>
#include <vector>

#include <ros/ros.h>
#include <tf/transform_datatypes.h>
#include <nav_msgs/Path.h>
#include <geometry_msgs/PoseStamped.h>
#include <geometry_msgs/PoseArray.h>
#include <visualization_msgs/MarkerArray.h>
#include "parameter_manager.h"
#include <Eigen/Dense>
#include "utility.h"
namespace GeneticAlgorithm
{
    /*!
   \brief A class for tracing and visualizing the path generated by the Planner
*/
    class PathPublisher
    {
    public:
        // / The default constructor initializing the path object and setting publishers for the same.
        PathPublisher(const ParameterPathPublisher &params)
        {
            params_ = params;
            std::string path_topic = "/path";
            std::string path_nodes_topic = "/pathNodes";
            std::string path_vehicle_topic = "/pathVehicle";
            std::string path_point_topic = "/points";
            // _________________
            // TOPICS TO PUBLISH
            pub_path_ = nh_.advertise<nav_msgs::Path>(path_topic, 1);
            pub_path_nodes_ = nh_.advertise<visualization_msgs::MarkerArray>(path_nodes_topic, 1);
            pub_path_vehicles_ = nh_.advertise<visualization_msgs::MarkerArray>(path_vehicle_topic, 1);
            pub_path_point_ = nh_.advertise<visualization_msgs::MarkerArray>(path_point_topic, 1);
            // CONFIGURE THE CONTAINER
            path_.header.frame_id = "path";
        }

        /*!
     \brief Given a node pointer the path to the root node will be traced recursively
     \param node a 3D node, usually the goal node
     \param i a parameter for counting the number of nodes
  */
        void UpdatePath(const std::vector<Eigen::Vector3d> &nodePath);

        void UpdatePoint(const std::vector<Eigen::Vector3d> &point_vec);
        /*!
     \brief Adds a segment to the path
     \param node a 3D node
  */
        void AddSegment(const Eigen::Vector3d &node);
        /*!
     \brief Adds a node to the path
     \param node a 3D node
     \param i a parameter for counting the number of nodes
  */
        void AddNode(const Eigen::Vector3d &node, int i);
        /*!
     \brief Adds a vehicle shape to the path
     \param node a 3D node
     \param i a parameter for counting the number of nodes
  */
        void AddVehicle(const Eigen::Vector3d &node, int i);

        void AddPoint(const Eigen::Vector3d &node, const int &i);
        // ______________
        // PUBLISH METHODS

        /// Clears the path
        void Clear();
        /// Publishes the path
        void PublishPath() { pub_path_.publish(path_); }
        /// Publishes the nodes of the path
        void PublishPathNodes() { pub_path_nodes_.publish(path_nodes_); }
        /// Publishes the vehicle along the path
        void PublishPathVehicles() { pub_path_vehicles_.publish(path_vehicles_); }

        void PublishPathPoints() { pub_path_point_.publish(path_points_); }

    private:
        /// A handle to the ROS node
        ros::NodeHandle nh_;
        /// Publisher for the path as a spline
        ros::Publisher pub_path_;
        /// Publisher for the nodes on the path
        ros::Publisher pub_path_nodes_;
        // publisher for all points from bezier
        ros::Publisher pub_path_point_;
        /// Publisher for the vehicle along the path
        ros::Publisher pub_path_vehicles_;
        /// Path data structure for visualization
        nav_msgs::Path path_;
        /// Nodes data structure for visualization
        visualization_msgs::MarkerArray path_nodes_;
        /// Vehicle data structure for visualization
        visualization_msgs::MarkerArray path_vehicles_;
        ParameterPathPublisher params_;
        visualization_msgs::MarkerArray path_points_;
    };
}
